# -*- coding: utf-8 -*-
"""SHA256.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1RWiB_Bweyp0JVd35l3-cfMOOVI5BM1Xv
"""

import hashlib
import random
import os, pickle
from Crypto.Hash import HMAC

def encrypt_string_sha(hash_string):
  sha_signature = hashlib.sha256(hash_string.encode()).hexdigest()
  return sha_signature

hash_string = 'hello world'
sha_signature = encrypt_string_sha(hash_string)
sha_signature

sha_256_constants = [
       0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
       0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
       0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
       0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
       0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
       0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
       0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
       0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
    ]

def pad(message):
  l = len(message) * 8
  k = (448 - l - 1) % 512
  tmp = b'1' + b'0' * k + bin(l)[2:].rjust(64, '0').encode()
  tmp = hex(int(tmp, 2))
  m = message + bytes.fromhex(tmp[2:])
  return m

pad('456789123'.encode())

def helper_split(chunk):
  words = []
  for i in range(16):
    words.append(int(chunk[4*i:4*i+4].hex(), 16))
  
  words += [0] * 48
  return words

def ROTR(x, n, w=32):
    return (x >> n) | (x << w - n)

type(ROTR(825373492, 7))

def mod_addition(*args):
  ans = 0
  for i in args:
    # print(ans)
    ans += i% 2**32
  return ans % 2**32

def sha256(message):
  padding_m = pad(message.encode())
  m = len(padding_m)//512
  if not m:
    m = 1

  fragments = []
  for i in range(m):
    fragments.append(padding_m[512*i:512*i+512])

  for i in fragments:
    words = helper_split(i)
    # print(list(map(type, words)))
    for i in range(16, len(words)):
      s0 = ROTR(words[i - 15], 7)^ROTR(words[i - 15], 18) ^ (words[i-15] >> 3)
      # print(type(s0))
      s1 = ROTR(words[i-2], 17)^ROTR(words[i-2], 19) ^ ROTR(words[i-2], 10)
      # print(type(s1))
      words[i] = mod_addition(words[i - 16], s0, words[i - 7], s1)


  h0, h1, h2, h3, h4, h5, h6, h7 = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19]

  a, b, c, d, e, f, g, h = h0, h1, h2, h3, h4, h5, h6, h7


  for i in range(64):
    sig0 = ROTR(a, 2)^ROTR(a, 13)^ROTR(a, 22)
    Ma = (a & b) ^ (a & c) ^ (b & c)
    t2 = mod_addition(sig0, Ma)
    sig1 = ROTR(e, 6) ^ ROTR(e, 11) ^ ROTR(e, 25)
    Ch = (e & f) ^ (~e & g)
    t1 = mod_addition(h, sig1, Ch, sha_256_constants[i], words[i])

    h = g
    g = f
    f = e
    e = mod_addition(d, t1)
    d = c
    c = b
    b = a
    a = mod_addition(t1, t2)
  print('its okay')

  h0 = mod_addition(h0, a)
  h1 = mod_addition(h1, b)
  h2 = mod_addition(h2, c)
  h3 = mod_addition(h3, d)
  h4 = mod_addition(h4, e)
  h5 = mod_addition(h5, f)
  h6 = mod_addition(h6, g)
  h7 = mod_addition(h7, h)
  H = [h0, h1, h2, h3, h4, h5, h6, h7]
  return b''.join(list(map(lambda x: bytes.fromhex(hex(x)[2:]), H))).hex()

print(sha256('confidential data'))

def hmkHMAC(key):
    if len(key)*8 > 512:
        key = sha256(key).bytes
    return Bits(key.ljust(512//8, b'\x00'))

def hmeHMAC(message, key):
    key = hmkHMAC(key)
    o = key ^ Bits('0x'+'5c'*(512//8))
    i = key ^ Bits('0x'+'36'*(512//8))
    a = o.tobytes() + sha256(i.tobytes() + message).bytes
    return sha256(a)

N = random.randint(0, 3540)
message = os.urandom(N)
key = os.urandom(random.randint(0, 500))

h = HMAC.new(b'Swordfish', digestmod=sha256)
h.update(message)
print(h.hexdigest())

print(hmeHMAC(message, key).hex(), key)

